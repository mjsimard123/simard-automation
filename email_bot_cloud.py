{"cells":[{"cell_type":"code","source":"import imaplib\nimport email\nfrom email.header import decode_header\nimport firebase_admin\nfrom firebase_admin import credentials, firestore\nfrom bs4 import BeautifulSoup\nimport datetime\nimport os\nimport hashlib\n\n# --- CONFIGURATION ---\n# Email Settings (Use Environment Variables for security in the cloud)\nEMAIL_USER = os.environ.get(\"EMAIL_USER\")\nEMAIL_PASS = os.environ.get(\"EMAIL_PASS\")\nIMAP_SERVER = \"imap.gmail.com\"\nSEARCH_SUBJECT = 'Appt InSights'\n\n# Firebase Settings\n# You will get a 'serviceAccountKey.json' from Firebase\nCRED_PATH = 'serviceAccountKey.json' \nAPP_ID = \"your-app-id-here\" # You will replace this with your specific App ID\n\n# Initialize Firebase\nif not firebase_admin._apps:\n    cred = credentials.Certificate(CRED_PATH)\n    firebase_admin.initialize_app(cred)\n\ndb = firestore.client()\n\ndef connect_to_mail():\n    try:\n        mail = imaplib.IMAP4_SSL(IMAP_SERVER)\n        mail.login(EMAIL_USER, EMAIL_PASS)\n        return mail\n    except Exception as e:\n        print(f\"Error connecting to email: {e}\")\n        return None\n\ndef extract_call_data(html_content):\n    soup = BeautifulSoup(html_content, \"html.parser\")\n    rows_data = []\n    \n    # Generic table parsing logic - customize based on actual email structure\n    rows = soup.find_all('tr')\n    for row in rows:\n        cols = row.find_all(['td', 'th'])\n        cols = [ele.text.strip() for ele in cols]\n        \n        # Validating row length to ensure it's data\n        if len(cols) >= 5: \n            # Map columns to object keys\n            # ADJUST THESE INDICES based on your actual email columns\n            call_record = {\n                \"date\": cols[0],      # e.g., 2023-10-25\n                \"time\": cols[1],      # e.g., 10:30 AM\n                \"caller\": cols[2],    # e.g., (555) 123-4567\n                \"agent\": cols[3],     # e.g., Sarah\n                \"store\": cols[4],     # e.g., Simard North\n                \"status\": cols[5] if len(cols) > 5 else \"Unknown\",\n                \"duration\": cols[6] if len(cols) > 6 else \"\",\n                \"notes\": cols[7] if len(cols) > 7 else \"\"\n            }\n            rows_data.append(call_record)\n            \n    return rows_data\n\ndef push_to_firestore(data):\n    if not data:\n        return\n    \n    collection_ref = db.collection('artifacts').document(APP_ID).collection('public').document('data').collection('calls')\n    \n    count = 0\n    for record in data:\n        # Create a unique ID for the document to prevent duplicates\n        # We hash the date+time+caller so we don't add the same call twice\n        unique_string = f\"{record['date']}{record['time']}{record['caller']}\"\n        doc_id = hashlib.md5(unique_string.encode()).hexdigest()\n        \n        doc_ref = collection_ref.document(doc_id)\n        \n        # Only set if it doesn't exist (or use set(..., merge=True) to update)\n        if not doc_ref.get().exists:\n            doc_ref.set(record)\n            count += 1\n            \n    print(f\"Successfully added {count} new records to Firestore.\")\n\ndef process_email():\n    mail = connect_to_mail()\n    if not mail:\n        return\n\n    mail.select(\"inbox\")\n    # specific search for unread emails or emails from last 24h is better\n    # Here we just look for the subject\n    status, messages = mail.search(None, f'(SUBJECT \"{SEARCH_SUBJECT}\")')\n    \n    if status == \"OK\":\n        email_ids = messages[0].split()\n        if email_ids:\n            # Process only the latest email\n            latest_id = email_ids[-1]\n            res, msg = mail.fetch(latest_id, \"(RFC822)\")\n            \n            for response in msg:\n                if isinstance(response, tuple):\n                    msg = email.message_from_bytes(response[1])\n                    \n                    if msg.is_multipart():\n                        for part in msg.walk():\n                            if part.get_content_type() == \"text/html\":\n                                body = part.get_payload(decode=True).decode()\n                                data = extract_call_data(body)\n                                push_to_firestore(data)\n                    else:\n                        if msg.get_content_type() == \"text/html\":\n                            body = msg.get_payload(decode=True).decode()\n                            data = extract_call_data(body)\n                            push_to_firestore(data)\n                            \n    mail.logout()\n\nif __name__ == \"__main__\":\n    process_email()","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}
